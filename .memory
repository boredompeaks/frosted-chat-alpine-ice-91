# Frosted Chat - Implementation Memory & Task Tracker

**Date Created**: 2025-11-10
**Project**: frosted-chat-alpine-ice-91
**Status**: Active Development

## üéØ Active Tasks

### Phase 1: Critical Fixes

#### 1. White Screen Issue (HIGH PRIORITY)
- **Issue**: `Uncaught ReferenceError: global is not defined` in simple-peer.js
- **Root Cause**: WebRTC library expects Node.js `global` variable
- **Fix Applied**: Added polyfill in `index.html` (2025-11-10)
  ```html
  <script>
    var global = globalThis;
  </script>
  ```
- **Status**: ‚úÖ FIXED - Awaiting user testing
- **Location**: `index.html:20-24`
- **Files Modified**:
  - `index.html` - Added global polyfill
  - `src/main.tsx` - Moved polyfill to top
- **Next Action**: Verify fix by running `npm run dev` and checking browser console
- **Notes**: This is a common issue with simple-peer. The polyfill must be before module imports.

#### 2. Key Management Edge Cases
- **Issue**: User logs in on new device without localStorage
- **Impact**: Cannot decrypt messages
- **Status**: ‚ö†Ô∏è PENDING
- **Required**:
  - Implement cloud backup of encrypted private keys
  - Add key recovery mechanism
  - Store encrypted private key in Supabase (user-specific)

#### 3. Message Synchronization Race Conditions
- **Issue**: Messages may appear out of order after reconnect
- **Status**: ‚ö†Ô∏è PENDING
- **Required**:
  - Implement message ordering by timestamp
  - Add deduplication logic
  - Better reconnection handling

### Phase 2: Performance Optimization

#### 1. Message Virtualization
- **Priority**: HIGH
- **Reason**: Large chat histories cause UI slowdowns
- **Solution**: Implement virtual scrolling
- **Libraries**: `react-window` or `react-virtualized`
- **Files to Modify**:
  - `src/components/chat/Conversation.tsx`
  - `src/components/chat/MessageList.tsx` (new)
- **Status**: ‚è≥ BACKLOG

#### 2. Image Lazy Loading
- **Priority**: MEDIUM
- **Implementation**: Add lazy loading for message images
- **Status**: ‚è≥ BACKLOG

#### 3. Bundle Optimization
- **Priority**: MEDIUM
- **Tasks**:
  - [ ] Code splitting for chat components
  - [ ] Dynamic imports for WebRTC
  - [ ] Tree shaking for crypto libraries
- **Status**: ‚è≥ BACKLOG

## üèóÔ∏è Architecture Implementation Details

### Encryption Flow (Detailed)

#### Initial Key Exchange
```
1. User A sends first message (plaintext)
2. User B receives, detects no encryption
3. User B generates new AES-256 key
4. User B encrypts AES key with User A's public RSA key
5. User B sends encrypted key to User A via chat
6. User A receives, decrypts with private RSA key
7. User A acknowledges receipt
8. Both sides store AES key in localStorage
9. All future messages encrypted with AES-256-GCM
```

**Code Path**:
- `keyManagement.ts:initiateKeyExchange()` - Create & send key
- `keyManagement.ts:receiveKey()` - Receive & install key
- `cryptoService.ts:prepareAESKeyForTransfer()` - Encrypt for sending
- `cryptoService.ts:receiveAESKeyFromTransfer()` - Decrypt & store

#### Message Encryption Flow
```
1. User types message
2. App checks for active AES key
3. If no key ‚Üí trigger key exchange
4. If key exists ‚Üí encrypt message
5. Message structure:
   {
     content: "Hello",           // Plaintext
     senderId: "user-uuid",      // Metadata
     timestamp: 1234567890       // Metadata
   }
6. Encrypt with AES-256-GCM:
   {
     ciphertext: "<base64>",
     iv: "<base64>",
     tag: "<base64>"
   }
7. Store encrypted object as JSON in messages.content
8. Send via Supabase Realtime
9. Recipient receives, decrypts with AES key
10. Render plaintext
```

**Code Path**:
- `crypto.ts:encryptMessageWithMetadata()` - Wrap + encrypt
- `crypto.ts:decryptMessageWithMetadata()` - Decrypt + unwrap
- `useChatData.ts:sendMessage()` - Send encrypted message
- `useChatData.ts` Effect - Decrypt on receive

#### Key Rotation Flow
```
1. Timer expires (48 hours)
2. Hook triggers: useKeyRotation
3. Generate new AES-256 key
4. Encrypt new key with recipient's RSA public key
5. Send encrypted key as system message
6. Recipient receives ‚Üí decrypt with private key
7. Switch to new key
8. Mark old key as expired
9. Update localStorage
10. Show toast: "Encryption key rotated"
```

**Code Path**:
- `useKeyRotation.ts:performRotation()` - Orchestrate rotation
- `keyManagement.ts:rotateKey()` - Create new key
- `keyManagement.ts:updateKeyStatus()` - Mark old key expired

### Database Operations

#### Message Send
```typescript
// useChatData.ts:sendMessage()
1. Check if AES key exists
2. If not ‚Üí create new key
3. Encrypt message with AES
4. Insert into Supabase:
   INSERT INTO messages (chat_id, sender_id, content, is_encrypted, created_at)
   VALUES (chatId, userId, encryptedPayload, true, NOW())
5. Trigger realtime update
6. Update chat.last_message_at
```

#### Message Receive
```typescript
// useChatData.ts (useEffect for realtime)
1. Listen to Supabase realtime channel
2. New message event triggers
3. Check is_encrypted flag
4. If encrypted ‚Üí decrypt with AES key
5. Parse metadata (senderId, timestamp)
6. Update messages state
7. Update unread count
8. Show notification
```

#### Key Storage
```sql
-- encryption_keys table structure
INSERT INTO encryption_keys (
  chat_id,           -- UUID of chat
  key_value,         -- Base64 of RSA-encrypted AES key
  status,            -- 'pending' | 'active' | 'expired'
  initiator_id,      -- UUID of who created this key
  last_rotation,     -- Timestamp of last rotation
  expires_at         -- When key expires (24h after creation)
);

-- Key lifecycle
1. Initiator creates ‚Üí status = 'pending'
2. Recipient acknowledges ‚Üí status = 'active'
3. Rotation needed ‚Üí create new row, mark old as 'expired'
```

### Real-Time Subscriptions

#### Presence Tracking
```typescript
// usePresence.ts
1. Create Supabase channel: `presence-chat-${chatId}`
2. Track user presence:
   {
     user_id: user.uuid,
     status: 'online' | 'away' | 'offline',
     last_seen: timestamp,
     is_typing: boolean,
     current_chat_id: chat.uuid
   }
3. Listen for events:
   - 'sync': Update all presence states
   - 'join': User came online
   - 'leave': User went offline
4. Update UI indicators
5. Cleanup on unmount
```

#### Message Updates
```typescript
// useChatData.ts (Realtime subscription)
1. Create channel: `messages-${chatId}`
2. Listen for INSERT events
3. On new message:
   - Fetch message data
   - If encrypted ‚Üí decrypt
   - Add to messages state
   - Update scroll position
4. Listen for UPDATE events (edited messages)
5. Listen for DELETE events
6. Cleanup on unmount
```

#### Typing Indicators
```typescript
// MessageInput.tsx
1. On input focus ‚Üí startTyping(chatId)
2. Set timeout 3s ‚Üí stopTyping(chatId)
3. On message sent ‚Üí stopTyping(chatId)

// usePresence.ts
1. Listen to presence updates
2. Check is_typing field
3. If typing in current chat ‚Üí show indicator
4. Hide after 3s timeout
```

### WebRTC Call Flow

#### Initiate Call
```typescript
// callService.ts:initiateCall()
1. Check encryption key exists
2. Initialize media stream (getUserMedia)
3. Create SimplePeer instance
4. Setup signaling channel: `webrtc-${chatId}`
5. Create offer
6. Send offer via signaling channel
7. Set local description
8. Wait for answer
9. On answer ‚Üí set remote description
10. ICE candidates exchanged
11. On stream ‚Üí set remote video
12. Update call state: 'calling' ‚Üí 'connected'
```

#### Answer Call
```typescript
// callService.ts:answerCall()
1. Receive call offer
2. Show incoming call UI
3. User accepts ‚Üí initialize media
4. Create SimplePeer (initiator: false)
5. Set remote description (offer)
6. Create answer
7. Send answer via signaling
8. ICE candidates exchanged
9. On stream ‚Üí set remote video
10. Update call state: 'ringing' ‚Üí 'connected'
```

#### Signaling Messages
```typescript
// SignalData structure
{
  type: 'offer' | 'answer' | 'ice-candidate' | 'call-start' | 'call-end',
  data: { sdp: string } | { candidate: string },
  from: user.uuid,
  to: other_user.uuid,
  chatId: chat.uuid,
  timestamp: epoch_millis
}

// Exchange flow
1. Initiator ‚Üí 'offer' ‚Üí Recipient
2. Recipient ‚Üí 'answer' ‚Üí Initiator
3. Both ‚Üí 'ice-candidate' ‚Üí Other party
4. Call end ‚Üí 'call-end' ‚Üí Cleanup
```

## üîç Code Reading Guide

### Understanding the Encryption

**Start Here**:
1. Read `crypto.ts:encryptMessage()` - See AES-GCM encryption
2. Read `crypto.ts:encryptKeyWithRSA()` - See RSA key wrapping
3. Read `cryptoService.ts:createNewAESKey()` - See key lifecycle
4. Read `keyManagement.ts:initiateKeyExchange()` - See full flow
5. Read `useChatData.ts:sendMessage()` - See in action

**Key Concepts**:
- RSA-2048 is ONLY for key exchange (encrypting the AES key)
- AES-256-GCM encrypts actual messages
- GCM provides both confidentiality AND authentication
- Keys stored client-side in localStorage
- Database stores only encrypted keys and messages

### Understanding Real-Time

**Start Here**:
1. Read `usePresence.ts` - See presence tracking
2. Read `useChatData.ts` (realtime subscription) - See message updates
3. Read `Conversation.tsx` - See UI integration
4. Read `MessageInput.tsx` - See typing indicators

**Key Concepts**:
- Supabase Realtime uses WebSocket
- Each feature has its own channel
- Presence is separate from messages
- Typing uses presence metadata

### Understanding WebRTC

**Start Here**:
1. Read `callService.ts:initiateCall()` - See outgoing calls
2. Read `callService.ts:answerCall()` - See incoming calls
3. Read `keyManagement.ts:TURN_SERVERS` - See network config
4. Read `CallPersistenceService.ts` - See call storage

**Key Concepts**:
- Signaling via Supabase Realtime
- Media via WebRTC (getUserMedia)
- TURN servers for NAT traversal
- Encryption is automatic (DTLS-SRTP)

## üìã Testing Scenarios

### Encryption Testing

**Test 1: Initial Key Exchange**
1. Create chat between User A and User B
2. User A sends message
3. ‚úÖ Message appears plaintext to User A
4. ‚úÖ User B receives plaintext
5. ‚úÖ Key exchange initiated
6. ‚úÖ AES key created and stored
7. ‚úÖ User A receives encrypted key
8. ‚úÖ Both users can decrypt messages
9. ‚úÖ New messages are encrypted

**Test 2: Key Rotation**
1. Start chat, complete key exchange
2. Wait for rotation timer OR click "Refresh Key"
3. ‚úÖ New AES key generated
4. ‚úÖ Old key marked expired
5. ‚úÖ New key distributed
6. ‚úÖ Old messages still decryptable
7. ‚úÖ New messages use new key

**Test 3: Multi-Message**
1. Send 10 messages in sequence
2. ‚úÖ All messages encrypt/decrypt correctly
3. ‚úÖ Messages arrive in order
4. ‚úÖ No duplicates
5. ‚úÖ Timestamps correct

### Real-Time Testing

**Test 1: Presence**
1. User A opens chat
2. ‚úÖ Shows as online to User B
3. User A switches to another tab
4. ‚úÖ Status changes to 'away' after 5 min
5. User A closes browser
6. ‚úÖ Status changes to 'offline' after 30s

**Test 2: Typing**
1. User A types in message input
2. ‚úÖ User B sees "User A is typing..."
3. User A stops typing
4. ‚úÖ Typing indicator disappears after 3s
5. User A sends message
6. ‚úÖ Typing indicator disappears immediately

### WebRTC Testing

**Test 1: Voice Call**
1. User A clicks "Call" button
2. ‚úÖ User B gets incoming call UI
3. User B accepts
4. ‚úÖ Both users hear audio
5. User A clicks "End Call"
6. ‚úÖ Call terminates
7. ‚úÖ Call record saved to database

**Test 2: Video Call**
1. Similar to voice call
2. ‚úÖ Both users see video
3. ‚úÖ Video quality acceptable
4. ‚úÖ Can toggle camera off/on

## üêõ Debugging Guide

### Debugging Encryption

**Problem: Messages not decrypting**
```typescript
// Add debug to useChatData.ts
useEffect(() => {
  console.log('üîê Encryption Debug:', {
    hasKey: !!encryptionKey,
    keyLength: encryptionKey?.length,
    messageCount: messages.length,
    encryptedCount: messages.filter(m => m.is_encrypted).length
  });
}, [encryptionKey, messages]);
```

**Check localStorage**:
```javascript
// Browser console
localStorage.getItem('frostedchat_aes_key')
// Should be base64 string, ~44 chars

// Or in DevTools Application tab
// Check Local Storage for calcita_key_* entries
```

**Verify RSA Keys**:
```typescript
// Check profiles.public_key
const { data } = await supabase
  .from('profiles')
  .select('public_key')
  .eq('id', userId);

// Should start with base64, ~350 chars for 2048-bit
```

### Debugging Real-Time

**Problem: Messages not updating**
```typescript
// Check channel subscription
const channel = supabase
  .channel('test')
  .on('postgres_changes', {
    event: 'INSERT',
    schema: 'public',
    table: 'messages',
    filter: `chat_id=eq.${chatId}`
  }, (payload) => {
    console.log('üì° Realtime event:', payload);
  })
  .subscribe((status) => {
    console.log('üì° Subscription status:', status);
  });
```

**Check Presence**:
```typescript
// In browser console
const presenceState = supabase.channel('presence-chat-test')
  .presenceState();
console.log('üë• Presence state:', presenceState);
```

### Debugging WebRTC

**Problem: Call doesn't connect**
```typescript
// In callService.ts
private handleSignal(signal: any) {
  console.log('üìû Signal received:', signal.type, signal.data);
  console.log('üìû Peer state:', this.peer?.state);
  console.log('üìû Connection state:', this.peer?.connectionState);

  if (signal.type === 'ice-candidate') {
    console.log('üìû ICE candidate:', signal.data.candidate);
  }
}
```

**Check TURN servers**:
```typescript
// In DevTools Network tab
// Filter: "turn:" or "stun:"
// Should see TURN/ICE requests
```

## üí° Future Enhancements

### Planned Features

1. **Group Chat Encryption**
   - Challenge: Each participant needs own AES key
   - Solution: Encrypt message multiple times (once per participant)
   - Performance: Use hybrid approach with per-group master key

2. **Ephemeral Messages**
   - Feature: Message self-destructs after X seconds
   - Implementation:
     - Store `expires_at` timestamp
     - Delete from DB when expires
     - Remove from UI on client when viewed
   - Code: Extend `messages` table with `expires_at` field

3. **File Attachments**
   - Challenge: Encrypt large files
   - Solution:
     - Split into chunks
     - Encrypt each chunk
     - Store in Supabase Storage
     - Share encryption key
   - Code: New `attachments` table

4. **Message Editing**
   - Feature: Edit sent messages
   - Implementation:
     - Add `edited_at` timestamp
     - Store edit history
     - Show "edited" label
   - Code: Modify `messages` table

5. **Screen Sharing**
   - Feature: Share screen in calls
   - Implementation: Use `getDisplayMedia()` API
   - Code: Extend `callService.ts`

6. **Message Search**
   - Feature: Full-text search
   - Challenge: Encrypted messages can't be searched
   - Solution: Client-side search of decrypted messages
   - Alternative: Encrypted search (Homomorphic encryption)

## üìä Performance Metrics

### Current Performance

**Message Loading**:
- First 50 messages: ~200ms
- Each additional page: ~150ms
- Decryption time per message: ~5ms

**Key Exchange**:
- RSA key generation: ~500ms (first time only)
- AES key generation: ~1ms
- Key encryption/decryption: ~10ms
- Total exchange time: ~50ms

**WebRTC**:
- Call setup: ~2-3 seconds
- ICE connection: ~1-2 seconds
- Media quality: Good on broadband, poor on 3G

### Optimization Targets

**Message Loading**:
- Target: First 50 messages < 100ms
- Method: Implement pagination + caching

**Key Exchange**:
- Target: < 20ms
- Method: Pre-generate RSA keys, cache them

**WebRTC**:
- Target: Call setup < 1 second
- Method: Better TURN servers, connection pooling

## üîê Security Checklist

### For Each Feature

- [ ] No plaintext in localStorage (except AES key)
- [ ] No plaintext in browser console
- [ ] No plaintext in network requests (except signaling)
- [ ] Private keys never leave client
- [ ] All crypto operations handle errors
- [ ] No key reuse across chats
- [ ] Proper random number generation
- [ ] Input sanitization
- [ ] XSS prevention
- [ ] CSRF protection (Supabase handles this)

### Before Each Release

- [ ] Run npm audit for dependencies
- [ ] Check for console.log of sensitive data
- [ ] Verify RLS policies
- [ ] Test key recovery
- [ ] Test key rotation
- [ ] Test on multiple browsers
- [ ] Performance test with large chats
- [ ] Memory leak check

---

**Next Review Date**: 2025-11-17
**Status**: Ready for development
**Blocking Issues**: White screen (pending user test)
**Ready for Implementation**: Performance optimizations, message features
**Requires Design Review**: Group chat encryption, file attachments
